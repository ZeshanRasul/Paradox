#pragma once

#include "../ParadoxMath.h"

using namespace DirectX;

class Rigidbody
{
protected:
	double inverseMass;
	XMFLOAT3X3 inverseInertiaTensor;
	double linearDamping;
	double angularDamping;
	XMFLOAT3 position;
	Quaternion orientation;
	XMFLOAT3 velocity;
	XMFLOAT3 rotation;
	
	// Derived Data:
	XMFLOAT3X3 inverseInertiaTensorWorld;
	double motion;
	bool isAwake;
	bool canSleep;
	XMFLOAT4X4 transformationMatrix;

	// Force and Torque Accumulators:
	XMFLOAT3 forceAccum;
	XMFLOAT3 torqueAccum;
	XMFLOAT3 acceleration;
	XMFLOAT3 lastFrameAcceleration;

public:
	void CalculateDerivedData();

	// Integrates the rigidbody forward by the given amount
	// Use a Newton-Euler integration method which is a 
	// linear approximation to the correct integral. (Could be inaccurate in some cases)
	void Integrate(double duration);
	void SetMass(const double mass);
	double GetMass() const;
	void SetInverseMass(const double inverseMass);
	double GetInverseMass() const;
	bool HasFiniteMass() const;

	// Sets inertia tensor which must be a full rank matrix and invertible
	// Invalidates internal data for the rigidbody, must be called 
	// After Integrate or CalculateInternals if trying to get data from the rigidbody
	void SetInertiaTensor(const XMFLOAT3X3& inertiaTensor);
	
	// Returns inertia tensor in RBs' local space
	XMFLOAT3X3 GetInertiaTensor() const;

	// Copies the current inertia tensor of RB into given matrix
	// Inertia tensor is expressed in world space
	void GetInertiaTensorWorld(XMFLOAT3X3* inertiaTensor) const;

	XMFLOAT3X3 GetInertiaTensorWorld() const;

	void SetInverseInertiaTensor(const XMFLOAT3X3& inverseInertiaTensor);
	void GetInverseInertiaTensor(XMFLOAT3X3* inverseInertiaTensor) const;
	XMFLOAT3X3 GetInverseInertiaTensor() const;

	void GetInverseInertiaTensorWorld(XMFLOAT3X3* inverseInertiaTensor) const;
	XMFLOAT3X3 GetInverseInertiaTensorWorld() const;

	void SetDamping(const double linearDamping, const double angularDamping);
	
	void SetLinearDamping(const double linearDamping);
	double GetLinearDamping() const;

	void SetAngularDamping(const double angularDamping);
	double GetAngularDamping() const;

	void SetPosition(const XMFLOAT3 &position);
	void SetPosition(const double x, const double y, const double z);
	void GetPosition(XMFLOAT3* position) const;
	XMFLOAT3 GetPosition() const;

	// The given orientation does not have to be normalized and can be zero
	void SetOrientation(const Quaternion& orientation);
	void SetOrientation(const double r, const double i, const double j, const double k);
	void GetOrientation(Quaternion* orientation) const;
	Quaternion GetOrientation() const;

	// Transforming a direction vector by this matrix turns it from
	// transforms it from local space to world space
	void GetOrientation(XMFLOAT3X3* orientationMatrix);

	// Transforming a vector by this matrix turns it from
	// transforms it from local space to world space
	void GetTransform(XMMATRIX* transform) const;
	XMMATRIX GetTransform() const;

	// Converts the given point from world space into bodys' local space
	XMFLOAT3 GetPointInLocalSpace(const XMFLOAT3& wsPoint) const;

	// Converts the given point from bodys' local space into world space
	XMFLOAT3 GetPointInWorldSpace(const XMFLOAT3& lsPoint) const;

	// Converts the given direction from world space into bodys' local space
	XMFLOAT3 GetDirectionInLocalSpace(const XMFLOAT3& wsDirection) const;

	// Converts the given direction from bodys' local space into world space
	XMFLOAT3 GetDirectionInWorldSpace(const XMFLOAT3& wsDirection) const;

	void SetVelocity(const XMFLOAT3& velocity);
	void SetVelocity(const double x, const double y, const double z);

	void GetVelocity(XMFLOAT3* velocity) const;
	XMFLOAT3 GetVelocity() const;

	void AddVelocity(const XMFLOAT3& deltaVelocity);

	void SetRotation(const XMFLOAT3& rotation);
	void SetRotation(const double x, const double y, const double z);

	void GetRotation(XMFLOAT3* rotation);
	XMFLOAT3 GetRotation() const;

	void AddRotation(const XMFLOAT3& deltaRotation);

	bool GetAwakeStatus() const
	{
		return isAwake;
	}

	// Sets the awake state of the body
	// If the body is not awake, its' velocities
	// Are also cancelled since a moving body that
	// Is not awake can cause problems in the simulation
	void SetAwakeStatus(const bool awakeStatus = true);

	bool GetCanSleepProperty() const
	{
		return canSleep;
	}

	// Sets CanSleep property.
	// Bodies under the players control or for which
	// transient forces applied each frame are not
	// predictable should be kept awake
	void SetCanSleep(const bool canSleep = true);

	/////////////////////////////////////////////
	// Retrieval functions for Dynamic Quantities
	/////////////////////////////////////////////
	
	// These functions provide access to the acceleration
	// properties of the body
	// The acceleration is generated by the simulation 
	// from the forces and torques applied to the rigidbody.
	// Acceleration cannot be directly influenced in the system.
	// It is set during integration and represents the acceleration
	// Experienced by the body of the previous simulation step

	// Returns current accumulated value for linear accumulation in world space
	// Acceleration accumulators are set during the integration step
	void GetLastFrameAcceleration(XMFLOAT3* linearAcceleration) const;
	XMFLOAT3 GetLastFrameAcceleration() const;

	/////////////////////////////////////////////
	// Force, Torque and Acceleration set up functions
	/////////////////////////////////////////////

	// Clears forces and torques in the accumulators.
	// Called automatically after each integration step
	void ClearAccumulators();

	// Adds given force to centre of mass of the rigid body.
	// The force is expressed in world coordinates
	void AddForce(const XMFLOAT3& force);

	// Adds given force to given point on the rigid body.
	// The force and point are both expressed in world coordinates
	// Because the force is not applied to the centre of mass, 
	// It may be split into a force and a torque
	void AddForceAtPoint(const XMFLOAT3& force, const XMFLOAT3& point);

	// Adds given force to given point on the rigid body.
	// The direction of the force is expressed in world coordinates
	// The application point is expressed in body local coordinates
	// This is useful for spring forces, or other forces fixed to the body
	void AddForceAtBodyPoint(const XMFLOAT3& force, const XMFLOAT3& point);

	// Adds given torque expressed in world coordinates
	void AddTorque(const XMFLOAT3& torque);

	// Sets the constant acceleration of the rigid body.
	void SetAcceleration(const XMFLOAT3& acceleration);
	void SetAcceleration(const double x, const double y, const double z);

	void GetAcceleration(XMFLOAT3* acceleration) const;
	XMFLOAT3 GetAcceleration() const;
};